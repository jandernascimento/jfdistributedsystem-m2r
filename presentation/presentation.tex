\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage[final]{pdfpages}
\usetheme{Goettingen}%Warsaw}
\usecolortheme{lily}
\setbeamertemplate{footline}[page number]
\title[Transactional storage for geo-replicated systems ]{Transactional storage for geo-replicated systems - overview}
\author{Jander Nascimento
\and Liviu Varga}
\institute{Universit√© Joseph Fourier}
\date{\today}
\begin{document}

\begin{frame}
\titlepage
\end{frame}

%\AtBeginSubsection[]
{
  \begin{frame}<beamer>
    \frametitle{Roadmap}
    \tableofcontents%[currentsection,currentsubsection]
  \end{frame}
}

%this is filled up with some sample code (we can remove it anytime)

\section{Introduction}

	\subsection{Overview}
	
		\begin{frame}{Objective}
		
			Reduce the system response time and increase the system availability
		
			How this is achieved?
			\begin{enumerate}
			\item Key-store application
			\item Asynchronous replication
			\end{enumerate}
			
			\begin{block}{Lema}
				Respecting causality order without compromise the throughput
			\end{block}		
		
		\end{frame}	
	
		\begin{frame}{Challenges}
		
		
		
		\end{frame}	
	
		\begin{frame}{State of the art}
		
			%talk about sinfonia compare with other the type server that dont use transactions
		\begin{itemize}
		\item Walter: key-value store database, supporting transactions and replication of data across remote sites
		\item There exists several systems (Sinfonia, Percolator) which offer support for transactions but they target applications on a single site. 
		\item Whereas the systems which target distributed application don't offer support for conflict-resolution logic
		\end{itemize}
		
		\end{frame}	
		
		\begin{frame}{Already existing frameworks}
		
			Other transaction infrastructure					
		
			\begin{enumerate}
			\item Sinfonia
			\item Percolator
			\end{enumerate}						
					
			Other storage system
			\begin{enumerate}
			\item PNUTS
			\item COPS
			\item Megastore
			\end{enumerate}		

		\end{frame}
	
		\begin{frame}{Basis of the solution}

			Evolved from:
			\begin{enumerate}
			\item Snapshot Isolation
			\item Ignoring primary site constraint
			\end{enumerate}

			\begin{block}{Nothing is so easy..}
				Snapshot Isolation protocol had to be changed to support multiple site store
			\end{block}
						
		\end{frame}		

\section{Walter framework}

	\subsection{Parallel Snapshot Isolation}
		\begin{frame}{Tools}
		
			%talk about cset and preferered sites
		
			Snapshot Isolation providing a base protocol for information exchange
			
			CSet a non structure way of keeping information with low conflict rate		
			%talk about what is exactly c set
		
		\end{frame}
		
		\begin{frame}{Properties}
		
		The following properties must be maintained:		
		\begin{itemize}
		\item (Site Snapshot Read) All operations read the most recent committed version at the transaction's site as of the time when the transaction began
		\item (No Write-Write Conflicts) The write sets of each pair of committed somewhere-concurrent transactions must be disjoint
		\item (Commit Causality Across Sites) If a transaction $T_{1}$ commits at a site A before a transaction $T_{2}$ starts at site A, then $T_{1}$ cannot commit after $T_{2}$ at any site
		\end{itemize}		
		
		\begin{itemize}
		\item (Site Snapshot Read) All operations read the most recent committed version at the transaction's site as of the time when the transaction began
		\item (No Write-Write Conflicts) The write sets of each pair of committed somewhere-concurrent transactions must be disjoint
		\item (Commit Causality Across Sites) If a transaction $T_{1}$ commits at a site A before a transaction $T_{2}$ starts at site A, then $T_{1}$ cannot commit after $T_{2}$ at any site
		\end{itemize}
		
		\end{frame}	

		\begin{frame}{Anomalies}
		
		Some anomalies that might affect some store systems are:
		\begin{itemize}
		\item Dirty read
		\item Non-repeatable read
		\item Lost update
		\item Short fork
		\item Long fork
		\item Conflict fork
		\end{itemize}		
		
		\end{frame}

		\begin{frame}{PSI and Conflict resolution}
		
		In order to improve conflict resolution, following approaches are used:
		
		\begin{itemize}
		
		\item Preferred sites: Each object is assigned a preferred site where writes to it can be committed without checking other sites for conflicts
		\item Conflict-free counting set objects: csets only allow incrementation or decremental of elements, operation which are commutative  
		
		\end{itemize}
		
		\end{frame}

		\begin{frame}{Types of transaction}
		
		\begin{itemize}
		
		\item Fast commit: used for objects which are local to the preferred site, involving two checks (objects are unmodified since the transaction started and unlocked)
		
		\item Slow commit: the preferred site of the object if a non-local one. This involves 2-phases: all the objects are unmodified and unlocked on their site, and after this it goes as a fast commit protocol		
		
		\end{itemize}

		\end{frame}
 	
		\begin{frame}{Transaction Durability}
		
		Two kinds of durability can be used:

		\begin{itemize}
		\item Normal
		\item Disaster-safe durability
		\end{itemize}		
		
		\end{frame} 	

		\begin{frame}{Limitations}

			\begin{enumerate}
			\item Short and long fork may happen
			\item Only a single store system per site used for writing
			\end{enumerate}
			
		\end{frame}
 	
	\subsection{Site Replication}
	 	
 	%talk about 	 	
	 	
		\begin{frame}{Introduction}
				
		\begin{itemize}
		
		\item Synchronizing among sites uses vector timestamps
		\item Each site has a local version number indicating the number of transactions in the snapshot
		\item This allows a casual ordering of the events
		
		\end{itemize}
		
		\end{frame}	 	
		
		\begin{frame}{Site Recovery}
		
		In case of a full site failure, those approaches can be applied:
		\begin{itemize}
		\item Conservative
		\item Agressive
		\end{itemize}		
		
		\end{frame}	 	
 	
 	
\section{Performance}

	\subsection{Features}
	
	\begin{frame}{Features}
	
		\begin{itemize}
		\item \textit{Asynchronous replication across sites.} Replication is done lazily in the background to reduce latency
		\item \textit{Efficient update-anywhere for certain objects.} Counting sets can be updated efficiently anywhere, while other objects can be updated efficiently at their preferred site
		\item \textit{Freedom from conflict-resolution logic}. which is complex to developers
		\item \textit{Strong isolation within each site.} Provided by PSI.
		\end{itemize}
	\end{frame}

	\subsection{Results}	

\end{document}
